import java.io.BufferedReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * TODO: complete description
 * Provides an implementation of the Parser Interface
 * <p>
 * Implementation details:
 * <p>
 * Correspondence:
 * 
 * @author Boyan Alexandrov
 */
public class ParserImp implements Parser {
	
	// ------------------------------------------------------------------------
    // PRIVATE VARIABLES
    // ------------------------------------------------------------------------
	
	/** instantiation of component to store records, symbols, literals */
	private final Program program = new ProgramImp();
	
	/** address of current instruction */
	private int locationCounter;
	
	/** line number of current instruction */
	private int lineNumber;

    /**
     * holds all the valid names of machine ops and pseudo ops, as well as
     * whether the location counter is incremented
     * TODO: add a boolean for whether a symbol in each op is relative
     */
    private static Map<String, Boolean> opTable = new HashMap<String, Boolean>();

    static {
        opTable.put("ADD", true);
        opTable.put("AND", true);
        opTable.put("BRN", true);
        opTable.put("BRZ", true);
        opTable.put("BRP", true);
        opTable.put("BRNZ", true);
        opTable.put("BRNP", true);
        opTable.put("BRZP", true);
        opTable.put("BRNZP", true);
        opTable.put("DBUG", true);
        opTable.put("JSR", true);
        opTable.put("JMP", true);
        opTable.put("JSRR", true);
        opTable.put("JMPR", true);
        opTable.put("LD", true);
        opTable.put("LDI", true);
        opTable.put("LDR", true);
        opTable.put("LEA", true);
        opTable.put("NOT", true);
        opTable.put("RET", true);
        opTable.put("ST", true);
        opTable.put("STI", true);
        opTable.put("STR", true);
        opTable.put("TRAP", true);
        opTable.put(".END", false);
        opTable.put(".EQU", false);
        opTable.put(".FILL", true);
        opTable.put(".STRZ", true);
        opTable.put(".BLKW", true);
    }

	// ------------------------------------------------------------------------
    // PRIVATE METHODS
    // ------------------------------------------------------------------------

    /**
     * Returns true if the label of {@code record} is valid
     * TODO: complete description
     */
    private boolean hasValidLabel(String record) {
        boolean result;
        char first = record.charAt(0);

        // first verify that first character is alphabetic and not 'R' or 'x'
        result = first != 'R' && first != 'x' && ((first > 'A' && first < 'Z')
                    || (first > 'a' && first < 'z'));

        // next ensure that the rest of the characters are alphanumeric
        for (int i = 1; i < record.indexOf(' '); i++) {
            char current = record.charAt(i);
            result = result && ((current > 'A' && current < 'Z')
                    || (current > 'a' && current < 'z')
                    || (current > '0' && current < '9'));
        }
        return result;
    }

	/**
	 * Returns the label of a line of assembly code if present
	 * TODO: complete description
	 */
	private String getLabel(String record) {
		String label = null;

        // if there is a label
        if (record.charAt(0) != ' ') {
            // check that it's a valid label
            if (hasValidLabel(record)) {
                // from the start of the line to the first blank character
                label = record.substring(0, record.indexOf(' '));
            } else {
                System.err.print("Invalid label at line " + lineNumber);
                System.exit(1);
            }
        } else if (getOpName(record).equals(".ORIG")
                || getOpName(record).equals(".EQU")) {
            System.err.print("Expected label at line " + lineNumber);
            System.exit(1);
        }
		return label;
	}
	
	/**
	 * Returns the op name of a line of assembly code
     * TODO: complete description
	 */
	private String getOpName(String record) {
        String opcode = null;

        if (record.charAt(9) != ' ') {
            opcode = record.substring(9, record.indexOf(' ', 9));
        } else {
            System.err.print("Expected instruction at line " + lineNumber);
            System.exit(1);
        }
        return opcode;
    }

    /**
     * Returns the operands in a String array
     * TODO: complete description
     */
    private String[] getOperands(String record) {
        String[] operands = null;

        if (!getOpName(record).equals(".STRZ")) {
            if (record.charAt(17) != ' ') {
                String ops = record.substring(17, record.indexOf(' ', 17));
                operands = ops.split(",");
            }
        } else {
            int endQuote = record.lastIndexOf('"');
            if (record.charAt(17) == '"' && endQuote > 17) {
                operands = new String[1];
                operands[0] = record.substring(18, endQuote);
            }
        }
        return operands;
    }

    /**
     * Initializes and populates a SourceRecord and adds it to program
     * TODO: complete description
     */
    private void addRecord(String label, String opCode, String[] operands,
                           int lineNumber, int location)
    {
        SourceRecord record = new SourceRecordImp();

        record.setLabel(label);
        record.setOpCode(opCode);
        record.setLineNumber(lineNumber);
        record.setLocation(location);

        // if there are any operands, add each
        for (int i = 0; i < operands.length; i++) {
            record.addArg(operands[i]);
        }
    }
	
	/**
	 * Handles the first pass of the assembly process
	 * TODO: complete description
	 */
	private void processLine(String record) {
        // if not a comment line
        if (record.charAt(0) != ';') {
            String label = getLabel(record);

            // if there is a label
            if (label != null) {
                // if not already in symbol table
                if (!program.hasSymbol(label)) {
                    // obey the MAX_SYMBOLS restriction
                    if (program.numberOfSymbols()
                            < MMXIAssembler.MAX_SYMBOLS)
                    {
                        // determine if a symbol is relative only for a
                        // relocatable program
                        if (program.isRelocatable()) {
                            //TODO: determine if a symbol is relative
                        } else {
                            program.addSymbol(label, locationCounter);
                        }
                    } else {
                        System.out.print("Warning: Maximum number of symbols" +
                                " reached.");
                    }
                } else {
                    System.err.print("Symbol " + label + " already defined.");
                    System.exit(1);
                }
            }

            // if instruction is a valid machine or pseudo op
            String opName = getOpName(record);
            if (opTable.containsKey(opName)) {
                // if locationCounter needs to be updated
                if (opTable.get(opName)) {
                    if (opName.equals(".STRZ")) {
                        //TODO
                    } else if (opName.equals(".BLKW")) {
                        //TODO
                    } else {
                        ++locationCounter;
                    }
                }
                // create SourceRecord and add it to program
                addRecord(label, opName, getOperands(record), lineNumber,
                        locationCounter);
            } else {
                System.err.print("Invalid operation at line" + lineNumber);
                System.exit(1);
            }
        }
        /*if line is not comment line

            if operand contains literal
                 if literal doesn't exist in literal table
                      add to literal table
                 end if
            end if
       end if*/
    }

	// ------------------------------------------------------------------------
    // PUBLIC METHODS
    // ------------------------------------------------------------------------
	
	@Override
	public Program parse(BufferedReader input, int maxRecords) {
		try {
			String inputLine = input.readLine();
			lineNumber = 1;
			
			// get to first non-comment line
			while (inputLine != null && inputLine.charAt(0) == ';') {
				inputLine = input.readLine();
				++lineNumber;
			}
			
			// check that the opfield contains .ORIG
            String opName = getOpName(inputLine);

            if (opName != ".ORIG") {
				System.err.println("Expected '.ORIG' at line " + lineNumber);
				System.exit(1);
			}
			
			// set segment info
            String label = getLabel(inputLine);
            String[] addr = getOperands(inputLine);

            program.setSegmentName(label);

            if (addr == null) {
                program.isRelocatable(true);
            } else {
                if (addr.length == 1) {
                    if (addr[0].length() == 5 && addr[0].charAt(0) == 'x') {
                        program.setFirstAddress(
                                Integer.parseInt(addr[0].substring(1), 16));
                    } else {
                        System.err.print("Invalid start address.");
                        System.exit(1);
                    }
                } else {
                    System.err.println("Too many operands in '.ORIG' record.");
                    System.exit(1);
                }
            }

            // add .ORIG record to program
            addRecord(label, opName, addr, lineNumber, locationCounter);

            while (!getOpName(inputLine).equals(".END")
                    && program.numberOfRecords() < maxRecords
                    && (inputLine = input.readLine()) != null)
            {
                processLine(inputLine);
                ++lineNumber;
            }

            if (program.numberOfRecords() == maxRecords) {
                System.out.println("Warning: Maximum number of records " +
                        "reached.");
            }

            // check if last line before stopping was a .END record
            if (getOpName(inputLine).equals(".END")) {
                if (getLabel(inputLine) != null) {
                    System.err.print("Encountered label at '.END' record.");
                }

                addr = getOperands(inputLine);

                // see if an execution address is specified, and if so make
                // sure it's valid
                if (addr == null) {
                    // no execution address specified, set it to start address
                    if (program.isRelocatable()) {
                        program.setExecAddress(0);
                    } else {
                        program.setExecAddress(program.getFirstAddress());
                    }
                } else {
                    // set execution address to the one specified
                    if (addr.length == 1) {
                        if (addr[0].length() == 5
                                && addr[0].charAt(0) == 'x')
                        {
                            program.setExecAddress(Integer.parseInt(
                                    addr[0].substring(1), 16));
                        } else {
                            System.err.print("Invalid execution address.");
                            System.exit(1);
                        }
                    } else {
                        System.err.println("Too many operands in '.END' " +
                                "record.");
                        System.exit(1);
                    }
                }
            } else {
                System.err.print("No '.END' record.");
                System.exit(1);
            }
		} catch (IOException e) {
            System.err.println("Could not read from input file: " + e);
        } finally {
            try {
                if (input != null) {
                    input.close();
                }
            } catch (IOException e) {
                System.err.println("Problem closing input file: " + e);
                System.exit (1);
            }
        }
		return program;
	}
}